===============================================================================
Xmlm - Sequential XML input/output and persistent cursor for OCaml
       Release %%VERSION%%
===============================================================================

Xmlm is an OCaml module providing sequential XML input/output and a
persistent cursor. It aims at making non valid (but well-formed) XML 
processing robust and painless.

The sequential interface can be used to process documents without
building an in-memory representation. It also lets the programmer
translate its own data structures to an XML representation and
vice-versa.

The cursor (zipper) allows to navigate and update a simple in-memory
tree representation of XML documents. Updates performed by the cursor
are persistent (non destructive).

To facilitate direct integration into projects, Xmlm is made of a
single module and distributed under a BSD license.

Project home page <http://erratique.ch/software/xmlm>
Contact <daniel.buenzli@erratique.ch>

Installation
------------

Xmlm was tested with OCaml 3.09.3. It can be directly embedded in your
project. Just copy xmlm.mli and xmlm.ml from the src/ directory to
your project. These two files contain everything : the code,
documentation and the license.

The documentation is generated by ocamldoc from xmlm.mli. You can find
a generated version in the doc/ directory of the distribution.

If you have ocamlbuild, Xmlm can be installed in the xmlm/ directory 
of `ocamlc -where` by typing :
 
  > ./build 
  > ./build install 

to install to a different location :

  > INSTALLDIR=/path/to/install/dir ./build install 

A test program, xmltrip, is provided in the test/ directory. It can
be built with :

  > ./build test

xmltrip reads xml files and outputs them back in various ways. It is
usefull to understand how Xmlm handles documents. xmltrip -help has more 
information.

If you need to parse XHTML, there is a file named xhtml.ml in the
test/ directory. It contains a caml list coupling each XHTML character
entity with its corresponding UTF-8 encoded character string. You can
use it to to program a suitable entity callback.